# Virtual Pointer Exploit Test Suite

Defenses such as LLVM-CFI and CFIXX attempt to prevent virtual table hijacking attacks. This test suite can be used to benchmark the effectiveness of these defense mechanisms against such attacks.

# Build and Run

1. Compile test.cpp with the defense mechanism to be benchmarked. For example, to test LLVM-CFI:

```
$ clang++-5.0 test.cpp -o test_cfi -flto -fsanitize=cfi -fvisibility=hidden -std=c++17
```

2. Run driver script that will execute the test program with all possible attack signatures. The driver script requires an argument specifying the executable test's filename:
```
$ /bin/bash test_driver.sh test_cfi
```

Default compiler example:

```
$ clang++-5.0 test.cpp -o test -std=c++17 -O2
$ /bin/bash test_driver.sh test
```

# Overview

Test cases cover a range of different attack scenarios and include variations of each attack scenario in different memory locations or type of class hierarchy for the involved objects. The test program takes in five arguments that specify a unique attack signature:

```
$ ./test <memory location> <class hierarchy> <type> <pointer> <vtable>  
```

## Memory Location

`<memory location>` specifies the memory region in which the attack is carried out:

1. `heap`
2. `stack`
3. `global`

## Class Heirarchy

`<class heirarchy>` refers to the relationship between the objects used in the attack:

1. `independent`
2. `inherited`

## Type

`<type>` refers to the type of attack that will be carried out:

1. `object_bounds_overflow`
2. `sub_object_bounds_overflow`
3. `type_confusion`
4. `use_after_free`
5. `fake_object`

## Pointer

`<pointer>` determines which pointer the exploit is going to target:

1. `vptr` : the exploit will overwrite the vptr in an object
2. `object_ptr` : the exploit changes the pointer to the object

## Vtable  

`<vtable>` determines the location of the vtable that the overwritten vptr points to(if any):

1. `reuse` : a vtable from an existing object is used
2. `injection` : a fake vtable is created and pointed to
3. `corruption`


# Attack Directory

There are five different attack scenarios, with variations of each of these forming the following test cases. Exploits not caught by defense mechanisms LLVM-CFI and CFIXX are also indicated below:

| Index |          Attack Type          | Memory Location | Class Heirarchy | Pointer | Vtable | LLVM-CFI | CFIXX | EffectiveSan |
|-------|-------------------------------|-----------------|-----------------|---------|--------|----------|-------|--------------|
|1|object_bounds_overflow|stack|independent|vptr|reuse|  |  |  |
|2|object_bounds_overflow|stack|independent|vptr|injection|  |  |  |
|3|object_bounds_overflow|stack|independent|object_ptr|reuse|  | X |  |
|4|sub_object_bounds_overflow|stack|independent|vptr|reuse|  |  |  |
|5|sub_object_bounds_overflow|stack|independent|vptr|injection|  |  |  |
|6|sub_object_bounds_overflow|stack|independent|object_ptr|reuse|  | X |  |
|7|type_confusion|stack|independent|vptr|reuse|  |  |  |
|8|type_confusion|stack|independent|vptr|injection|  |  |  |
|9|type_confusion|stack|independent|object_ptr|reuse|  | X |  |
|10|use_after_free|stack|independent|vptr|reuse|  |  |  |
|11|use_after_free|stack|independent|vptr|injection|  |  |  |
|12|use_after_free|stack|independent|object_ptr|reuse|  | X |  |
|13|fake_object|stack|independent|vptr|reuse|  |  |  |
|14|fake_object|stack|independent|vptr|injection|  |  |  |
|15|fake_object|stack|independent|object_ptr|reuse|  | X |  |
|16|object_bounds_overflow|stack|inherited|vptr|reuse| X |  |  |
|17|object_bounds_overflow|stack|inherited|vptr|injection|  |  |  |
|18|object_bounds_overflow|stack|inherited|object_ptr|reuse| X | X | X |
|19|sub_object_bounds_overflow|stack|inherited|vptr|reuse| X |  |  |
|20|sub_object_bounds_overflow|stack|inherited|vptr|injection|  |  |  |
|21|sub_object_bounds_overflow|stack|inherited|object_ptr|reuse| X | X | X |
|22|type_confusion|stack|inherited|vptr|reuse| X |  |  |
|23|type_confusion|stack|inherited|vptr|injection|  |  |  |
|24|type_confusion|stack|inherited|object_ptr|reuse| X | X | X |
|25|use_after_free|stack|inherited|vptr|reuse|  |  |  |
|26|use_after_free|stack|inherited|vptr|injection|  |  |  |
|27|use_after_free|stack|inherited|object_ptr|reuse|  | X |  |
|28|fake_object|stack|inherited|vptr|reuse| X |  |  |
|29|fake_object|stack|inherited|vptr|injection|  |  |  |
|30|fake_object|stack|inherited|object_ptr|reuse| X | X |  |
|31|object_bounds_overflow|heap|independent|vptr|reuse|  |  |  |
|32|object_bounds_overflow|heap|independent|vptr|injection|  |  |  |
|33|object_bounds_overflow|heap|independent|object_ptr|reuse|  | X |  |
|34|sub_object_bounds_overflow|heap|independent|vptr|reuse|  |  |  |
|35|sub_object_bounds_overflow|heap|independent|vptr|injection|  |  |  |
|36|sub_object_bounds_overflow|heap|independent|object_ptr|reuse|  | X |  |
|37|type_confusion|heap|independent|vptr|reuse|  |  |  |
|38|type_confusion|heap|independent|vptr|injection|  |  |  |
|39|type_confusion|heap|independent|object_ptr|reuse|  | X |  |
|40|use_after_free|heap|independent|vptr|reuse|  |  |  |
|41|use_after_free|heap|independent|vptr|injection|  |  |  |
|42|use_after_free|heap|independent|object_ptr|reuse|  | X | X |
|43|fake_object|heap|independent|vptr|reuse|  |  | X |
|44|fake_object|heap|independent|vptr|injection|  |  |  |
|45|fake_object|heap|independent|object_ptr|reuse|  | X |  |
|46|object_bounds_overflow|heap|inherited|vptr|reuse| X |  |  |
|47|object_bounds_overflow|heap|inherited|vptr|injection|  |  |  |
|48|object_bounds_overflow|heap|inherited|object_ptr|reuse| X | X | X |
|49|sub_object_bounds_overflow|heap|inherited|vptr|reuse| X |  |  |
|50|sub_object_bounds_overflow|heap|inherited|vptr|injection|  |  |  |
|51|sub_object_bounds_overflow|heap|inherited|object_ptr|reuse| X | X | X |
|52|type_confusion|heap|inherited|vptr|reuse| X |  |  |
|53|type_confusion|heap|inherited|vptr|injection|  |  |  |
|54|type_confusion|heap|inherited|object_ptr|reuse| X | X | X |
|55|use_after_free|heap|inherited|vptr|reuse|  |  |  |
|56|use_after_free|heap|inherited|vptr|injection|  |  |  |
|57|use_after_free|heap|inherited|object_ptr|reuse|  | X |  |
|58|fake_object|heap|inherited|vptr|reuse| X |  | X |
|59|fake_object|heap|inherited|vptr|injection|  |  |  |
|60|fake_object|heap|inherited|object_ptr|reuse| X | X |  |
|61|object_bounds_overflow|global|independent|vptr|reuse|  |  |  |
|62|object_bounds_overflow|global|independent|vptr|injection|  |  |  |
|63|object_bounds_overflow|global|independent|object_ptr|reuse|  | X |  |
|64|sub_object_bounds_overflow|global|independent|vptr|reuse|  |  |  |
|65|sub_object_bounds_overflow|global|independent|vptr|injection|  |  |  |
|66|sub_object_bounds_overflow|global|independent|object_ptr|reuse|  | X |  |
|67|type_confusion|global|independent|vptr|reuse|  |  |  |
|68|type_confusion|global|independent|vptr|injection|  |  |  |
|69|type_confusion|global|independent|object_ptr|reuse|  | X |  |
|70|fake_object|global|independent|vptr|reuse|  |  |  |
|71|fake_object|global|independent|vptr|injection|  |  |  |
|72|fake_object|global|independent|object_ptr|reuse|  | X |  |
|73|object_bounds_overflow|global|inherited|vptr|reuse| X |  |  |
|74|object_bounds_overflow|global|inherited|vptr|injection|  |  |  |
|75|object_bounds_overflow|global|inherited|object_ptr|reuse| X | X | X |
|76|sub_object_bounds_overflow|global|inherited|vptr|reuse| X |  |  |
|77|sub_object_bounds_overflow|global|inherited|vptr|injection|  |  |  |
|78|sub_object_bounds_overflow|global|inherited|object_ptr|reuse| X | X | X |
|79|type_confusion|global|inherited|vptr|reuse| X |  |  |
|80|type_confusion|global|inherited|vptr|injection|  |  |  |
|81|type_confusion|global|inherited|object_ptr|reuse| X | X | X |
|82|fake_object|global|inherited|vptr|reuse| X |  |  |
|83|fake_object|global|inherited|vptr|injection|  |  |  |
|84|fake_object|global|inherited|object_ptr|reuse| X | X |  |
