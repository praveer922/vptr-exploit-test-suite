# Overview

hijack takes in four arguments:
```
$ ./hijack <pointer> <memory location> <vtable> <class hierarchy> <type>
```

## Pointer

`<pointer>` determines which pointer the exploit is going to target and has two possible inputs:

1. `vptr` : the exploit will overwrite the vptr in an object
2. `object_ptr` : the exploit changes the pointer to the object

## Memory Location

`<memory location>` specifies in which memory region the attack is carried out. It has 3 possible inputs:

1. `heap`
2. `stack`
3. `global`

## Vtable  

`<vtable>` determines the location of the vtable that the overwritten vptr points to(if any). It has 3 possible inputs:

1. `reuse` : a vtable from an existing object is used
2. `injection` : a fake vtable is created and pointed to
3. `corruption`

## Class Heirarchy

`<class heirarchy>` refers to the relationship between the objects used in the attack. It has 3 possible inputs:

1. `independent`
2. `inherited`
3. `multiple_inheritance`

## Type

`<type>` refers to the type of attack that will be carried out and has 6 possible inputs:

1. `object_bounds_overflow`
2. `sub_object_bounds_overflow`
3. `type_confusion`
4. `use_after_free`
5. `buffer_overflow`
6. `pointer_overwrite`

# Implementation

The implementation of each exploit is given here:

* vptr
  * heap
      * reuse
          * independent
              * object_bounds_overflow
                ```
                $ ./hijack vptr heap reuse independent object_bounds_overflow

                A *a = new A(1);
                B *b = new B(1.0);
                void **buf = new void *[10];
                long long idx = (void **)b - buf;
                void *ptr;
                memcpy((void *)&ptr, (void *)a, sizeof(void *));
                overflow(buf, idx, ptr);
                b->g();
                ```
              * sub_object_bounds_overflow
                ```
                $ ./hijack vptr heap reuse independent sub_object_bounds_overflow

                A *a = new A(1);
                B *b = new B(1.0);
                void **buf = b->buf;
                long long idx = (void **)b - buf;
                void *ptr;
                memcpy((void *)&ptr, (void *)a, sizeof(void *));
                overflow(buf, idx, ptr);
                b->g();
                ```
              * type_confusion
                ```
                $ ./hijack vptr heap reuse independent type_confusion

                A *a = new A(1);
                B *b = new B(1.0);
                C *c;
                void *a_vptr;
                memcpy((void *)&a_vptr, (void *)a, sizeof(void *)); //valid memcpy
                c = (C *)b;  // invalid cast from b to c
                confusion(c, a_vptr);
                b->g();
                ```
              * use_after_free
                ```
                $ ./hijack vptr heap reuse independent use_after_free

                A *a = new A(1);
                C *c = new C;
                delete c;
                B *b = new B(1.0);
                assert((void *)c == (void *)b);
                void *ptr;
                memcpy((void *)&ptr, (void *)a, sizeof(void *));
                confusion(c, ptr);
                b->g();
                ```
          * inherited
          * multiple_inheritance

      * injection
          * independent
          * inherited
          * multiple_inheritance

      * corruption
          * independent
          * inherited
          * multiple_inheritance

  * stack
      * reuse
          * independent
          * inherited
          * multiple_inheritance

      * injection
          * independent
          * inherited
          * multiple_inheritance

      * corruption
          * independent
          * inherited
          * multiple_inheritance

  * global
      * reuse
          * independent
          * inherited
          * multiple_inheritance

      * injection
          * independent
          * inherited
          * multiple_inheritance

      * corruption
          * independent
          * inherited
          * multiple_inheritance

* object_ptr
    * heap
        * reuse
            * independent
            * inherited
                * type_confusion
                  ```
                  $ ./hijack object_ptr heap reuse inherited type_confusion

                  Base *e = new Evil();
                  Normal *n;

                  n = static_cast<Normal*>(e);
                  n->g();
                  ```
                * use_after_free
                  ```
                  $ ./hijack object_ptr heap reuse inherited use_after_free

                  Normal *n = new Normal();
                  delete n;
                  Evil *e = new Evil();
                  n->g();
                  ```
            * multiple_inheritance

        * injection
            * independent
            * inherited
            * multiple_inheritance

        * corruption
            * independent
            * inherited
            * multiple_inheritance
    * stack
        * reuse
            * independent
            * inherited
            * multiple_inheritance

        * injection
            * independent
            * inherited
            * multiple_inheritance

        * corruption
            * independent
            * inherited
            * multiple_inheritance

    * global
        * reuse
            * independent
            * inherited
            * multiple_inheritance

        * injection
            * independent
            * inherited
            * multiple_inheritance

        * corruption
            * independent
            * inherited
            * multiple_inheritance
