#include <cassert>
#include <cstdio>
#include <string>
#include <string.h>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

string memoryLocation;
string targetObject;
string type;
string pointer;
string vtable;
string exploit;

void * customHeap = malloc(4000);

class A
{
    private:

        int x;
        void *pad[3];

    public:
        A() {}
        A(int y) : x(y) { }

        virtual void g(void)
        {
            printf("HIJACKED!\n");
        }

        void * operator new(size_t size) {
          void * a = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(A));
          return a;
        }

        void operator delete(void * a) {
            customHeap = a;
        }
};


class B
{
    private:



    public:
        float z;
        void *buf[3];
        B() {}
        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }

        void * operator new(size_t size) {
          void * b = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(B));
          return b;
        }

        void operator delete(void * b) {
            customHeap = b;
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];
        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }

        void * operator new(size_t size) {
          void * c = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(C));
          return c;
        }

        void operator delete(void * c) {
            customHeap = c;
        }
};

class D {
public:
  float z;
  void *buf[3];
  D() {}
  D(float w) : z(w) { }

  void g(void)
  {
      printf("OK\n");
  }

  void * operator new(size_t size) {
    void * a = customHeap;
    customHeap = (void *)((char *)customHeap + sizeof(D));
    return a;
  }

  void operator delete(void * a) {
      customHeap = a;
  }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C * c, void *ptr)  {
  c->set(ptr);
}

class Base {
public:
  void *buf[3];
  int x;

  Base() {}

  Base(int x) {
    this->x = x;
  }

  virtual void g() {
    printf("OK!\n");
  }

  void * operator new(size_t size) {
    void * b = customHeap;
    customHeap = (void *)((char *)customHeap + sizeof(Base));
    return b;
  }

  void operator delete(void * b) {
      customHeap = b;
  }
};

class Evil: public Base {
  public:
    Evil() {}

    Evil(int x) {
      this->x = x;
    }

    virtual void g() {
      printf("HIJACKED!\n");
    }

    void * operator new(size_t size) {
      void * e = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(Evil));
      return e;
    }

    void operator delete(void * e) {
        customHeap = e;
    }
};

class Normal: public Base {
  public:
    Normal() {}

    Normal(int x) {
      this->x = x;
    }

    virtual void g() {
      printf("OK\n");
    }

    void * operator new(size_t size) {
      void * n = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(Normal));
      return n;
    }

    void operator delete(void * n) {
        customHeap = n;
    }
};


Base * globalBase;
Normal * globalNormal;
Evil * globalEvil;
D * globalD;
C * globalC;
B * globalB;
A * globalA;

A globalAObj = A(1);
B globalBObj = B(1.0);
D globalDObj = D(1.0);
Normal globalNormalObj = Normal();
Evil globalEvilObj = Evil();
void * globalBuf[10];
void * fakeTargetGlobal[10];


void createBaseOnStack() {
  Base b = Base();
  globalBase = &b;
  printf("globalBase at %p\n", globalBase);
}

void createNormalOnStack() {
  Normal n = Normal();
  globalNormal = &n;
  printf("globalNormal at %p\n", globalNormal);
}

void createEvilOnStack() {
  Evil e = Evil();
  globalEvil = &e;
  printf("globalEvil at %p\n", globalEvil);
}

void createDonStack() {
  D d = D();
  globalD = &d;
  printf("globalD at %p\n", globalD);
}

void createConStack() {
  C c = C();
  globalC = &c;
  printf("globalC at %p\n", globalC);
}

void createBonStack() {
  B b = B(1.0);
  globalB = &b;
  printf("globalB at %p\n", globalB);
}

void createAonStack() {
  A a = A(1);
  globalA = &a;
  printf("globalA at %p\n", globalA);
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}

void callg(void * target) {
  if(targetObject == "independent" ) {
    ((B *)target)->g();
  } else if(targetObject == "inherited") {
    ((Base *)target)->g();
  } else if(targetObject == "non_virtual") {
    ((A *)target)->g();
  }
}

void ** getBuf(void * target) {
  if(targetObject == "independent" ) {
    return ((B *)target)->buf;
  } else if(targetObject == "inherited") {
    return ((Base *)target)->buf;
  } else if(targetObject == "non_virtual"){
    return ((D *)target)->buf;                             //// TODO:: more targetObject types
  } else {
    return NULL;
  }
}

void deallocate(void * badObject) {
  if(targetObject == "independent") {
    delete (A *)badObject;
  } else if(targetObject == "inherited") {
    delete (Evil *)badObject;
  } else if(targetObject == "non_virtual") {
    delete (A *)badObject;
  }
}

int main(int argc, char * argv[])
{
    memoryLocation = argv[1];
    targetObject = argv[2];
    type = argv[3];
    pointer = argv[4];
    vtable = argv[5];
    exploit = argv[6];

    printf("Attack Signature: %s %s %s %s %s %s\n", type.c_str(), memoryLocation.c_str(), targetObject.c_str(), pointer.c_str(), vtable.c_str(), exploit.c_str());


    /** ################################## SETUP ################################### **/

    /** Object Creation **/
    A * a;
    B * b;
    D * d;
    void **buf;
    void * bad_vptr;
    Normal * n;
    Evil * e;
    Evil e_stack = Evil(1);
    Normal n_stack = Normal(1);
    A a_stack = A(1);
    B b_stack = B(1.0);
    D d_stack = D(1.0);
    void * stackBuf[10];
    void * fakeTarget;
    void * fakeTargetStackSpace[10];

    if(memoryLocation == "heap") {
      a = new A(1);
      b = new B(1.0);
      d = new D(1.0);
      buf = new void *[10];
      n = new Normal(1);
      e = new Evil(1);
      fakeTarget = (void *)malloc(sizeof(B));
    } else if(memoryLocation == "stack") {
      a = &a_stack;
      b = &b_stack;
      d = &d_stack;
      buf = stackBuf;
      n = &n_stack;
      e = &e_stack;
      fakeTarget = (void *)fakeTargetStackSpace;
    } else if(memoryLocation == "global") {
      a = &globalAObj;
      b = &globalBObj;
      d = &globalDObj;
      buf = globalBuf;
      n = &globalNormalObj;
      e = &globalEvilObj;
      fakeTarget = (void *)fakeTargetGlobal;
    } else {
      printf("Invalid memory location\n");
      return 0;
    }

    /** Bad virtual pointer **/
    FakeVirtualTable fake_table;
    fake_table.g = fake_g;

    if(vtable == "reuse") {
      if(targetObject == "independent") {
        memcpy((void *)&bad_vptr, (void *)a, sizeof(void *));
      } else if(targetObject == "inherited") {
        memcpy((void *)&bad_vptr, (void *)e, sizeof(void *));
      } else if(targetObject == "non_virtual") {
        memcpy((void *)&bad_vptr, (void *)a, sizeof(void *));
      }
    } else if(vtable == "injection") {
      bad_vptr = (void *)&fake_table;
    } else {
      printf("Invalid vtable\n");
      return 0;
    }

    /** Object pointer initialization **/
    void * target;
    void * badObject;
    size_t targetSize;
    if(targetObject == "independent") {
      target = (void *)b;
      targetSize = sizeof(B);
      badObject = (void *)a;
    } else if(targetObject == "inherited") {
      target = (void *)n;
      targetSize = sizeof(Normal);
      badObject = (void *)e;
    } else if(targetObject == "non_virtual") {
      target = (void *)d;
      targetSize = sizeof(D);
      badObject = (void *)a;
    } else {
      printf("Invalid Class Heirarchy");
      return 0;
    }

    /** ################################## EXPLOITS ################################### **/

    if(exploit == "false") {
      if(targetObject == "non_virtual") {
        ((D *)target)->g();
      } else {
        if(type == "fake_object") {
          memcpy((void*)fakeTarget, (void*)target, targetSize);
          callg(fakeTarget);
        } else {
          callg(target);
        }
      }
      return 0;
    }

    if(type == "object_bounds_overflow") {
      if(pointer == "vptr") {
        // (1)(7)(13)(17) hijack heap/stack/global independent/inherited object_bounds_overflow vptr reuse
        long long idx = (void **)target - buf;
        overflow(buf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        //(10) hijack heap/stack independent/inherited object_bounds_overflow object_ptr
        long long idx = &target - (void **)buf;
        overflow(buf,idx,badObject);
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "sub_object_bounds_overflow") {
      if(pointer == "vptr") {
        // (2)(8)(14) hijack heap/stack independent sub_object_bounds_overflow vptr reuse
        void ** targetBuf = getBuf(target);
        long long idx = (void **)target - targetBuf;
        overflow(targetBuf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        void ** targetBuf = getBuf(target);
        long long idx = &target - targetBuf;
        overflow(targetBuf,idx,badObject);
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "type_confusion") {
      if(pointer =="vptr") {
        // (3)(9)(15) hijack heap/stack independent type_confusion vptr reuse
        C *c;
        c = (C *)target;
        confusion(c,bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        // (5)(11) heap/stack inherited type_confusion object_ptr
        target = badObject;
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "use_after_free") {
        if(memoryLocation == "stack") {
          if(targetObject == "independent") {
            createAonStack();
            globalA->g();
          } else if(targetObject == "inherited") {
            createEvilOnStack();
            globalEvil->g();
          }
        } else if(memoryLocation == "heap") {
          deallocate(badObject);
          if(targetObject == "independent") {
            ((A *)badObject)->g();
          } else if(targetObject == "inherited") {
            ((Evil *)badObject)->g();
          }
        }
    } else if(type == "reuse_after_free") {
      if(pointer =="vptr") {
        if(memoryLocation == "heap") {
          if(targetObject == "independent") {
            // (4)(16) hijack heap independent use_after_free vptr reuse
            C *c = new C;
            delete c;
            b = new B(1.0);
            globalC = c; //get past optimization
            globalB = b;
            //assert((void *)c == (void *)b);
            confusion(c,bad_vptr);
            b->g();
          } else if(targetObject == "inherited") {
            Base * base = new Base();
            delete base;
            n = new Normal();
            globalBase = base;  //get past optimization
            globalNormal = n;
            //assert((void *)base == (void *)n);
            confusion((C*)base,bad_vptr);
            n->g();
          } else if(targetObject == "non_virtual") {
            a = new A();
            delete a;
            d = new D();
            globalA = a;
            globalD = d;
            confusion((C *)a,bad_vptr);
            ((A *)d)->g();
          }
        } else if(memoryLocation == "stack") {
          if(targetObject == "independent") {
            createConStack();
            createBonStack();
            //assert((void *)globalC == (void *)globalB);
            confusion(globalC,bad_vptr);
            globalB->g();
          } else if(targetObject == "inherited") {
            createBaseOnStack();
            createNormalOnStack();
            //assert((void *)globalBase == (void *)globalNormal);
            confusion((C *)globalBase,bad_vptr);
            globalNormal->g();
          } else if(targetObject == "non_virtual") {
            createAonStack();
            createDonStack();
            confusion((C *)globalA,bad_vptr);
            ((A *)globalD)->g();
          }
        }
      } else if(pointer == "object_ptr") {
        if(memoryLocation == "heap") {
          if(targetObject == "independent") {
            B * b = new B(1.0);
            delete b;
            A * a = new A(1);
            globalB = b; //get past optimization
            globalA = a;
            //assert((void *)a == (void *)b);
            b->g();
          } else if(targetObject == "inherited") {
            // (6) hijack heap inherited use_after_free object_ptr
            Normal *n = new Normal();
            delete n;
            Evil *e = new Evil();
            globalNormal = n; //get past optimization
            globalEvil = e;
            n->g();
          } 
        } else if(memoryLocation  == "stack") {
          if(targetObject == "independent") {
            createBonStack();
            createAonStack();
            globalB->g();
          } else if(targetObject == "inherited") {
            // (12) hijack stack inherited use_after_free object_ptr
            createNormalOnStack();
            createEvilOnStack();
            globalNormal->g();
          }
        }
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "fake_object") {
      if(pointer == "object_ptr") {
          memcpy((double *)badObject + 1, ((double *)target)+1, targetSize-8);              // ########################################## TODO: include this attack or not?
          callg(badObject);
      }
    }

    return 0;
}
