#include <cassert>
#include <cstdio>
#include <string>
#include <string.h>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

string memoryLocation;
string classHeirarchy;
string type;
string pointer;
string vtable;

class A
{
    private:

        int x;
        void *pad[3];

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C * c, void *ptr)  {
  c->set(ptr);
}

class Base {
public:
  void *buf[3];
  int x;
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Base * globalBase;
Normal * globalNormal;
Evil * globalEvil;
C * globalC;
B * globalB;
A * globalA;

A globalAObj = A(1);
B globalBObj = B(1.0);
Normal globalNormalObj = Normal();
Evil globalEvilObj = Evil();
void * globalBuf[10];
void * fakeTargetGlobal[10];


void createBaseOnStack() {
  Base b = Base();
  globalBase = &b;
  printf("globalBase at %p\n", globalBase);
}

void createNormalOnStack() {
  Normal n = Normal();
  globalNormal = &n;
  printf("globalNormal at %p\n", globalNormal);
}

void createEvilOnStack() {
  Evil e = Evil();
  globalEvil = &e;
  printf("globalEvil at %p\n", globalEvil);
}

void createConStack() {
  C c = C();
  globalC = &c;
  printf("globalC at %p\n", globalC);
}

void createBonStack() {
  B b = B(1.0);
  globalB = &b;
  printf("globalB at %p\n", globalB);
}

void createAonStack() {
  A a = A(1);
  globalA = &a;
  printf("globalA at %p\n", globalA);
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}

void callg(void * target) {
  if(classHeirarchy == "independent") {
    ((B *)target)->g();
  } else if(classHeirarchy == "inherited") {
    ((Base *)target)->g();
  } else if(classHeirarchy == "multiple_inheritance") {

  } else {

  }
}

void ** getBuf(void * target) {
  if(classHeirarchy == "independent") {
    return ((B *)target)->buf;
  } else if(classHeirarchy == "inherited") {
    return ((Base *)target)->buf;
  } else if(classHeirarchy == "multiple_inheritance") {
    return NULL;
  } else {
    return NULL;
  }
}


int main(int argc, char * argv[])
{
    memoryLocation = argv[1];
    classHeirarchy = argv[2];
    type = argv[3];
    pointer = argv[4];
    if(argc>5) {
    vtable = argv[5];
    }

    cout << "Attack Signature: " << memoryLocation << " " << classHeirarchy << " " << type << " " << pointer << " " << vtable << endl;

    /** ################################## SETUP ################################### **/

    FakeVirtualTable fake_table;
    fake_table.g = fake_g;

    A * a;
    B * b;
    void **buf;
    void * bad_vptr;
    Normal * n;
    Evil * e;
    Evil e_stack = Evil();
    Normal n_stack = Normal();
    A a_stack = A(1);
    B b_stack = B(1.0);
    void * stackBuf[10];
    void * fakeTarget;
    void * fakeTargetStackSpace[10];

    if(memoryLocation == "heap") {
      a = new A(1);
      b = new B(1.0);
      buf = new void *[10];
      n = new Normal();
      e = new Evil();
      fakeTarget = (void *)malloc(sizeof(B));
    } else if(memoryLocation == "stack") {
      a = &a_stack;
      b = &b_stack;
      buf = stackBuf;
      n = &n_stack;
      e = &e_stack;
      fakeTarget = (void *)fakeTargetStackSpace;
    } else if(memoryLocation == "global") {
      a = &globalAObj;
      b = &globalBObj;
      buf = globalBuf;
      n = &globalNormalObj;
      e = &globalEvilObj;
      fakeTarget = (void *)fakeTargetGlobal;
    } else {
      printf("Invalid memory location\n");
      return 0;
    }

    if(vtable == "reuse") {
      if(classHeirarchy == "independent") {
        memcpy((void *)&bad_vptr, (void *)a, sizeof(void *));
      } else if(classHeirarchy == "inherited") {
        memcpy((void *)&bad_vptr, (void *)e, sizeof(void *));
      }
    } else if(vtable == "injection") {
      bad_vptr = (void *)&fake_table;
    } else if(vtable == "corruption") {
      return 0;
    } else {
      printf("Invalid vtable\n");
      return 0;
    }

    void * target;
    void * badObject;
    size_t targetSize;
    if(classHeirarchy == "independent") {
      target = (void *)b;
      targetSize = sizeof(B);
      badObject = (void *)a;
    } else if(classHeirarchy == "inherited") {
      target = (void *)n;
      targetSize = sizeof(Normal);
      badObject = (void *)e;
    } else if(classHeirarchy == "multiple_inheritance") {

    } else {
      printf("Invalid Class Heirarchy");
      return 0;
    }

    /** ################################## EXPLOITS ################################### **/

    if(type == "object_bounds_overflow") {
      if(pointer == "vptr") {
        // (1)(7)(13)(17) hijack heap/stack/global independent/inherited object_bounds_overflow vptr reuse
        long long idx = (void **)target - buf;
        overflow(buf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        //(10) hijack heap/stack independent/inherited object_bounds_overflow object_ptr
        long long idx = &target - (void **)buf;
        buf[idx] = badObject;
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "sub_object_bounds_overflow") {
      if(pointer == "vptr") {
        // (2)(8)(14) hijack heap/stack independent sub_object_bounds_overflow vptr reuse
        void ** targetBuf = getBuf(target);
        long long idx = (void **)target - targetBuf;
        overflow(targetBuf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        void ** targetBuf = getBuf(target);
        long long idx = &target - targetBuf;
        targetBuf[idx] = badObject;
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "type_confusion") {
      if(pointer =="vptr") {
        // (3)(9)(15) hijack heap/stack independent type_confusion vptr reuse
        C *c;
        c = (C *)target;
        confusion(c,bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        // (5)(11) heap/stack inherited type_confusion object_ptr
        target = badObject;
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "use_after_free") {
      if(pointer =="vptr") {
        if(memoryLocation == "heap") {
          if(classHeirarchy == "independent") {
            // (4)(16) hijack heap independent use_after_free vptr reuse
            C *c = new C;
            delete c;
            b = new B(1.0);
            globalC = c; //get past optimization
            globalB = b;
            assert((void *)c == (void *)b);
            confusion(c,bad_vptr);
            b->g();
          } else if(classHeirarchy == "inherited") {
            Base * base = new Base();
            delete base;
            n = new Normal();
            globalBase = base;  //get past optimization
            globalNormal = n;
            assert((void *)base == (void *)n);
            confusion((C*)base,bad_vptr);
            n->g();
          }
        } else if(memoryLocation == "stack") {
          if(classHeirarchy == "independent") {
            createConStack();
            createBonStack();
            assert((void *)globalC == (void *)globalB);
            confusion(globalC,bad_vptr);
            globalB->g();
          } else if(classHeirarchy == "inherited") {
            createBaseOnStack();
            createNormalOnStack();
            assert((void *)globalBase == (void *)globalNormal);
            confusion((C *)globalBase,bad_vptr);
            globalNormal->g();
          }
        }
      } else if(pointer == "object_ptr") {
        if(memoryLocation == "heap") {
          if(classHeirarchy == "independent") {
            B * b = new B(1.0);
            delete b;
            A * a = new A(1);
            globalB = b; //get past optimization
            globalA = a;
            assert((void *)a == (void *)b);
            b->g();
          } else if(classHeirarchy == "inherited") {
            // (6) hijack heap inherited use_after_free object_ptr
            Normal *n = new Normal();
            delete n;
            Evil *e = new Evil();
            globalNormal = n; //get past optimization
            globalEvil = e;
            n->g();
          }
        } else if(memoryLocation  == "stack") {
          if(classHeirarchy == "independent") {
            createBonStack();
            createAonStack();
            globalB->g();
          } else if(classHeirarchy == "inherited") {
            // (12) hijack stack inherited use_after_free object_ptr
            createNormalOnStack();
            createEvilOnStack();
            globalNormal->g();
          }
        }
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "fake_object") {
        if(pointer == "vptr") {
          memcpy((void*)fakeTarget, (void*)&bad_vptr, sizeof(void*));
          callg(fakeTarget);
      } else if(pointer == "object_ptr") {
          memcpy((double *)badObject + 1, ((double *)target)+1, targetSize-8);
          assert(((Normal *)target)->x == ((Evil *)badObject)->x);
          callg(badObject);
      }
    }



    return 0;
}
