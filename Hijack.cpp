#include <cassert>
#include <cstdio>
#include <string>
#include <string.h>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

static int hijackCount = 0;

class A
{
    private:

        int x;

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
            hijackCount++;
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C *c, void *ptr)   // valid
{
    c->set(ptr);
}

class Base {
public:
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
      hijackCount++;
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Normal * createNormalOnStack() {
  double x =0;
  Normal n = Normal();
  return &n;
}

void createEvilAndPrintFromNormal(Normal * n) {
  Evil e = Evil();
  assert((void *)n == (void *)&e);
  n->g();
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}


int main(int argc, char * argv[])
{
    string memoryLocation = argv[1];
    string classHeirarchy = argv[2];
    string type = argv[3];
    string pointer = argv[4];
    string vtable;
    if(argc>5) {
    vtable = argv[5];
    }

    cout << "Attack: " << memoryLocation << " " << classHeirarchy << " " << type << " " << pointer << " " << vtable << endl;

    FakeVirtualTable fake_table;
    fake_table.g = fake_g;

    // A * a_heap = new A(1);
    // B * b_heap = new B(1.0);
    // void **heapBuf = new void *[10];
    // void **b_heapBuf = b_heap->buf;
    // void *a_heap_vptr;
    // memcpy((void *)&a_heap_vptr, (void *)a_heap, sizeof(void *));

    // Base * e_base_heap = new Evil();
    // Base * n_base_heap = new Normal();
    // Normal * n_normal_heap = new Normal();
    // void *e_base_heap_vptr;
    // memcpy((void *)&e_base_heap_vptr, (void *)e_base_heap, sizeof(void *));

    // A a_stack = A(1);
    // B b_stack = B(1.0);
    // void * stackBuf[10];
    // void ** b_stackBuf = b_stack.buf;
    // void *a_stack_vptr;
    // memcpy((void *)&a_stack_vptr, (void *)&a_stack, sizeof(void *));

    // Evil e_evil_stack = Evil();

    A * a;
    B * b;
    void **buf;
    void * a_vptr;
    Base * base_e;
    Base * base_n;
    Normal * n;
    Evil * e;
    void * e_vptr;

    if(memoryLocation == "heap") {
      a = new A(1);
      b = new B(1.0);
      buf = new void *[10];
      base_e = new Evil();
      base_n = new Normal();
      n = new Normal();
      e = new Evil();
    } else if(memoryLocation == "stack") {
      A a_stack = A(1);
      B b_stack = B(1.0);
      void * stackBuf[10];
      a = &a_stack;
      b = &b_stack;
      buf = stackBuf;
      Base base_n_stack = Normal();
      Base base_e_stack = Evil();
      Evil e_stack = Evil();
      Normal n_stack = Normal();
      base_e = &base_e_stack;
      base_n = &base_n_stack;
      n = &n_stack;
      e = &e_stack;
    } else if(memoryLocation == "global") {

    } else {
      printf("Invalid memory location\n");
      return 0;
    }

    memcpy((void *)&a_vptr, (void *)a, sizeof(void *));
    memcpy((void *)&e_vptr, (void *)base_e, sizeof(void *));


    if(classHeirarchy.compare("independent") == 0) {          // #### INDEPENDENT
      if(type.compare("object_bounds_overflow") == 0) {           // ### OBJECT BOUNDS OVERFLOW
        if(pointer.compare("vptr") == 0) {                            // ## VPTR
          if(vtable.compare("reuse") == 0) {                              // # REUSE
            // (1)(7) hijack heap/stack/global independent object_bounds_overflow vptr reuse
            long long idx = (void **)b - buf;
            overflow(buf, idx, a_vptr);
            b->g();
          } else if(vtable.compare("injection") == 0) {                   // # INJECTION
            // (13) hijack heap independent object_bounds_overflow vptr injection
            long long idx = (void **)b - buf;
            overflow(buf,idx,(void *)&fake_table);
            b->g();
          } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

          } else {
            printf("Invalid vtable\n");
          }
        } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR
            //Not Possible?
        } else {
          printf("Invalid Pointer\n");
        }

      } else if(type.compare("sub_object_bounds_overflow") == 0) {  // ### SUB OBJECT BOUNDS OVERFLOW
        if(pointer.compare("vptr") == 0) {                            // ## VPTR
          if(vtable.compare("reuse") == 0) {                              // # REUSE
            // (2)(8) hijack heap/stack independent sub_object_bounds_overflow vptr reuse
            long long idx = (void **)b - b->buf;
            overflow(b->buf, idx, a_vptr);
            b->g();
          } else if(vtable.compare("injection") == 0) {                   // # INJECTION
            // (14) hijack heap independent sub_object_bounds_overflow vptr injection
            long long idx = (void **)b - b->buf;
            overflow(b->buf, idx, (void *)&fake_table);
            b->g();
          } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR
            // Not Possible?
        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("type_confusion") == 0) {            // ### TYPE CONFUSION
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {
            // (3)(9) hijack heap/stack independent type_confusion vptr reuse
            C *c;
            c = (C *)b;
            confusion(c,a_vptr);
            b->g();
          } else if(vtable.compare("injection") == 0) {
            // (15) hijack heap independent type_confusion vptr injection
            C *c;
            c = (C *)b;
            confusion(c,(void *)&fake_table);
            b->g();

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {
            // Not possible ?
        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("use_after_free") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {
            // (4) hijack heap independent use_after_free vptr reuse
            C *c = new C;
            delete c;
            b = new B(1.0);
            assert((void *)c == (void *)b);
            confusion(c,a_vptr);
            b->g();
          } else if(vtable.compare("injection") == 0) {
            // (16) hijack heap independent use_after_free vptr injection
            C *c = new C;
            delete c;
            b = new B(1.0);
            assert((void *)c == (void *)b);
            confusion(c,(void *)&fake_table);
            b->g();
          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {
            // Not Possible
        } else {
          printf("Invalid Pointer");
        }

      } else {
        printf("Invalid Type");
      }

    } else if(classHeirarchy.compare("inherited") == 0) {
      if(type.compare("object_bounds_overflow") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {
            // (17) hijack heap inherited object_bounds_overflow vptr reuse
            long long idx = (void **)base_n - buf;
            overflow(buf,idx,e_vptr);
            base_n->g();
          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {
          //(10) hijack stack inherited object_bounds_overflow object_ptr
          long long idx = &base_n - (Base **)buf;
          buf[idx] = base_e;
          base_n->g();

        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("sub_object_bounds_overflow") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {

        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("type_confusion") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {
          // (5)(11) heap/stack inherited type_confusion object_ptr
          n = static_cast<Normal*>(base_e);
          n->g();
        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("use_after_free") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {
          if(memoryLocation == "heap") {
              // (6) hijack heap inherited use_after_free object_ptr
              Normal *n = new Normal();
              delete n;
              Evil *e = new Evil();
              n->g();
              //TODO: make enough objects to get same address  ########################################################
          } else if(memoryLocation  == "stack") {
              // (12) hijack stack inherited use_after_free object_ptr
              Normal * n = createNormalOnStack();
              createEvilAndPrintFromNormal(n);
              //TODO: pass pointer through global variable      ###############################################
          }
        } else {
          printf("Invalid Pointer");
        }

      } else {
        printf("Invalid Type");
      }

    } else if(classHeirarchy.compare("multiple_inheritance") == 0) {
      if(type.compare("object_bounds_overflow") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {

        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("sub_object_bounds_overflow") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {

        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("type_confusion") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {

        } else {
          printf("Invalid Pointer");
        }

      } else if(type.compare("use_after_free") == 0) {
        if(pointer.compare("vptr") == 0) {
          if(vtable.compare("reuse") == 0) {

          } else if(vtable.compare("injection") == 0) {

          } else if(vtable.compare("corruption") == 0) {

          } else {
            printf("Invalid vtable");
          }
        } else if(pointer.compare("object_ptr") == 0) {

        } else {
          printf("Invalid Pointer");
        }

      } else {
        printf("Invalid Type");
      }

    } else {
      printf("Invalid Class Heirarchy\n");
    }
    //
    // //13. indirect pointer overwrite (pointer subterfuge)
    // {
    //   Evil * e = new Evil();
    //   Normal * n = new Normal();
    //   void * ptr;
    //   void * buf[10];
    //   long long idx = &ptr - buf;
    //   buf[idx] = (void *)n;
    //   assert(ptr == (void *)n);
    //   memcpy(ptr, (void *)e, sizeof(void *));
    //   n->g();
    // }
    //
    //
    // // TYPE OF ATTACK X STACK/HEAP/GlOBAL X HEIRARCHY(Independent, Inheritance, Multiple Inheritance)



    return 0;
}
