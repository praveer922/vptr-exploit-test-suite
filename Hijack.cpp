/*
 *        __  __           _   _           ____
 *   ___ / _|/ _| ___  ___| |_(_)_   _____/ ___|  __ _ _ __
 *  / _ \ |_| |_ / _ \/ __| __| \ \ / / _ \___ \ / _` | '_ \
 * |  __/  _|  _|  __/ (__| |_| |\ V /  __/___) | (_| | | | |
 *  \___|_| |_|  \___|\___|\__|_| \_/ \___|____/ \__,_|_| |_|
 *
 * Proof-of-concept control-flow hijacking (vptr overwrite) example.
 *
 * If the example is working it should print "HIJACKED" 4 times.
 *
 * EffectiveSan should detect:
 * - 2x type error;
 * - 1x bounds overflow; and
 * - 1x sub-object bounds overflow.
 */

#include <cassert>
#include <cstdio>
#include <cstring>
#include <string>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

static int hijackCount = 0;

class A
{
    private:

        int x;

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
            hijackCount++;
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C *c, void *ptr)   // valid
{
    c->set(ptr);
}

class Base {
public:
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
      hijackCount++;
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Normal * createNormalOnStack() {
  double x =0;
  Normal n = Normal();
  return &n;
}

void createEvilAndPrintFromNormal(Normal * n) {
  Evil e = Evil();
  assert((void *)n == (void *)&e);
  n->g();
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}


int main(int argc, char * argv[])
{
    string type = argv[0];
    string memLocation = argv[1];
    string classHeirarchy = argv[2];

    // 1. OBJECT BOUNDS OVERFLOW
    {
        A *a = new A(1);
        B *b = new B(1.0);
        void **buf = new void *[10];
        long long idx = (void **)b - buf;
        void *ptr;
        memcpy((void *)&ptr, (void *)a, sizeof(void *));
        overflow(buf, idx, ptr);
        b->g();
    }

    // 2. SUB-OBJECT BOUNDS OVERFLOW (UNDERFLOW)
    {
        A *a = new A(1);
        B *b = new B(1.0);
        void **buf = b->buf;
        long long idx = (void **)b - buf;
        void *ptr;
        memcpy((void *)&ptr, (void *)a, sizeof(void *));
        overflow(buf, idx, ptr);
        b->g();
    }

    // 3. TYPE CONFUSION (vptr corruption)
    {
        A *a = new A(1);
        B *b = new B(1.0);
        C *c;
        void *a_vptr;
        memcpy((void *)&a_vptr, (void *)a, sizeof(void *)); //valid memcpy
        c = (C *)b;  // invalid cast from b to c
        confusion(c, a_vptr);
        b->g();
    }

    // 4. USE-AFTER-FREE
    // Note: This will manifest as a type error.
    {
        A *a = new A(1);
        C *c = new C;
        delete c;
        B *b = new B(1.0);
        assert((void *)c == (void *)b);
        void *ptr;
        memcpy((void *)&ptr, (void *)a, sizeof(void *));
        confusion(c, ptr);
        b->g();
    }

    //5. Type Confusion(object pointer)
    {
      Base *e = new Evil();
      Normal *n;

      n = static_cast<Normal*>(e);
      n->g();
    }

    //6. Use-after-free dangling pointer(make enough objects to get same address)
    {
      Normal *n = new Normal();
      delete n;
      Evil *e = new Evil();
      n->g();
    }




    //Stack variations
    //7. (1) on Stack
    {
      A a = A(1);
      B b = B(1.0);
      void * buf[10];
      long long idx = (void **)&b - buf;
      void *ptr;
      memcpy((void *)&ptr, (void *)&a, sizeof(void *));
      overflow(buf,idx,ptr);
      (&b)->g();
    }

    //8. (2) on Stack
    {
      A a = A(1);
      B b = B(1.0);
      void **buf = b.buf;
      long long idx = (void **)&b - buf;
      void *ptr;
      memcpy((void *)&ptr, (void *)&a, sizeof(void *));
      overflow(buf, idx, ptr);
      (&b)->g();
    }

    //9. (5) on Stack
    {
      Evil e = Evil();
      Normal* n;
      n = (Normal *) &e;
      n->g();
    }

    //10. (3) on Stack
    {
      A a = A(1);
      B b = B(1.0);
      C *c;
      void *a_vptr;
      memcpy((void *)&a_vptr, (void *)&a, sizeof(void *)); //valid memcpy
      c = (C *)&b;  // invalid cast from b to c
      confusion(c, a_vptr);
      (&b)->g();
    }

    //11. Use-after-free(dangling pointer) on stack (pass the pointer through global or heap)
    {
      Normal * n = createNormalOnStack();
      createEvilAndPrintFromNormal(n);
    }

    //12. overwrite Normal * ptr to an Evil ptr
    {
      Base * e = new Evil();
      Base * n = new Normal();
      Base * buf[10];
      long long idx = &n - buf;
      buf[idx] = e;
      n->g();
    }

    //13. indirect pointer overwrite (pointer subterfuge)
    {
      Evil * e = new Evil();
      Normal * n = new Normal();
      void * ptr;
      void * buf[10];
      long long idx = &ptr - buf;
      buf[idx] = (void *)n;
      assert(ptr == (void *)n);
      memcpy(ptr, (void *)e, sizeof(void *));
      n->g();
    }

    {
      printf("%s%d%s%d\n", "Hijack Count = ",hijackCount,"/",13);
    }

    //14. Overwrite vptr to own vtable constructed in buffer -
    //not working currently, segfaults (Evil::g in vtable )
    {
      A *a = new A(1);
      B *b = new B(1.0);
      void **buf = new void *[10];
      long long idx = (void **)b - buf;

      FakeVirtualTable custom_table;
      custom_table.g = fake_g;

      //void *ptr;
      //memcpy((void *)&ptr, (void *)&custom_table, sizeof(void *));
      overflow(buf, idx, (void *)&custom_table);
      b->g();
    }

    // TYPE OF ATTACK X STACK/HEAP/GlOBAL X HEIRARCHY(Independent, Inheritance, Multiple Inheritance)



    return 0;
}
