#include <cassert>
#include <cstdio>
#include <string>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

static int hijackCount = 0;

class A
{
    private:

        int x;

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
            hijackCount++;
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C *c, void *ptr)   // valid
{
    c->set(ptr);
}

class Base {
public:
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
      hijackCount++;
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Normal * createNormalOnStack() {
  double x =0;
  Normal n = Normal();
  return &n;
}

void createEvilAndPrintFromNormal(Normal * n) {
  Evil e = Evil();
  assert((void *)n == (void *)&e);
  n->g();
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}


int main(int argc, char * argv[])
{
    string memoryLocation = argv[1];
    string classHeirarchy = argv[2];
    string type = argv[3];
    string pointer = argv[4];
    string vtable;
    if(argc>5) {
    vtable = argv[5];
    }

    FakeVirtualTable fake_table;
    fake_table.g = fake_g;

    A * a_heap = new A(1);
    B * b_heap = new B(1.0);
    void **heapBuf = new void *[10];
    void **b_heapBuf = b_heap->buf;
    void *a_heap_vptr;
    memcpy((void *)&a_heap_vptr, (void *)a_heap, sizeof(void *));

    Base * e_base_heap = new Evil();
    Base * n_base_heap = new Normal();
    Normal * n_normal_heap = new Normal();
    void *e_base_heap_vptr;
    memcpy((void *)&e_base_heap_vptr, (void *)e_base_heap, sizeof(void *));

    A a_stack = A(1);
    B b_stack = B(1.0);
    void * stackBuf[10];
    void ** b_stackBuf = b_stack.buf;
    void *a_stack_vptr;
    memcpy((void *)&a_stack_vptr, (void *)&a_stack, sizeof(void *));

    Evil e_evil_stack = Evil();



    if(memoryLocation.compare("heap") == 0) {               // ##### HEAP
      if(classHeirarchy.compare("independent") == 0) {          // #### INDEPENDENT
        if(type.compare("object_bounds_overflow") == 0) {           // ### OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE
              // (1) hijack heap independent object_bounds_overflow vptr reuse
              printf("Exploit (1)\n");
              long long idx = (void **)b_heap - heapBuf;
              overflow(heapBuf, idx, a_heap_vptr);
              b_heap->g();
            } else if(vtable.compare("injection") == 0) {                   // # INJECTION
              // (13) hijack heap independent object_bounds_overflow vptr injection
              printf("Exploit (13)\n");
              long long idx = (void **)b_heap - heapBuf;
              overflow(heapBuf,idx,(void *)&fake_table);
              b_heap->g();
            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR
              //Not Possible?
          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {  // ### SUB OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE
              // (2) hijack heap independent sub_object_bounds_overflow vptr reuse
              printf("Exploit (2)\n");
              long long idx = (void **)b_heap - b_heapBuf;
              overflow(b_heapBuf, idx, a_heap_vptr);
              b_heap->g();
            } else if(vtable.compare("injection") == 0) {                   // # INJECTION
              // (14) hijack heap independent sub_object_bounds_overflow vptr injection
              printf("Exploit (14)\n");
              long long idx = (void **)b_heap - b_heapBuf;
              overflow(b_heapBuf, idx, (void *)&fake_table);
              b_heap->g();
            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR
              // Not Possible?
          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {            // ### TYPE CONFUSION
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {
              // (3) hijack heap independent type_confusion vptr reuse
              printf("Exploit (3)\n");
              C *c;
              c = (C *)b_heap;
              confusion(c,a_heap_vptr);
              b_heap->g();
            } else if(vtable.compare("injection") == 0) {
              // (15) hijack heap independent type_confusion vptr injection
              printf("Exploit (15)\n");
              C *c;
              c = (C *)b_heap;
              confusion(c,(void *)&fake_table);
              b_heap->g();

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
              // Not possible ?
          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {
              // (4) hijack heap independent use_after_free vptr reuse
              printf("Exploit (4)\n");
              C *c = new C;
              delete c;
              B *b = new B(1.0);
              assert((void *)c == (void *)b);
              confusion(c,a_heap_vptr);
              b->g();
            } else if(vtable.compare("injection") == 0) {
              // (16) hijack heap independent use_after_free vptr injection
              printf("Exploit (16)\n");
              C *c = new C;
              delete c;
              B *b = new B(1.0);
              assert((void *)c == (void *)b);
              confusion(c,(void *)&fake_table);
              b->g();
            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
              // Not Possible
          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("inherited") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {
              // (17) hijack heap inherited object_bounds_overflow vptr reuse
              printf("Exploit (17)\n");
              long long idx = (void **)n_base_heap - heapBuf;
              overflow(heapBuf,idx,e_base_heap_vptr);
              n_base_heap->g();

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
            // (5) heap inherited type_confusion object_ptr
            printf("Exploit (5)\n");
            n_normal_heap = static_cast<Normal*>(e_base_heap);
            n_normal_heap->g();
          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
            // (6) hijack heap inherited use_after_free object_ptr
            printf("Exploit (6)\n");
            Normal *n = new Normal();
            delete n;
            Evil *e = new Evil();
            n->g();
            //TODO: make enough objects to get same address  ########################################################
          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("multiple_inheritance") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else {
        printf("Invalid Class Heirarchy\n");
      }

    } else if(memoryLocation.compare("stack") == 0) {       // ##### STACK

      if(classHeirarchy.compare("independent") == 0) {          // #### INDEPENDENT
        if(type.compare("object_bounds_overflow") == 0) {           // ### OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE
              // (7) hijack stack independent object_bounds_overflow vptr reuse
              printf("Exploit (7)\n");
              long long idx = (void **)&b_stack - stackBuf;
              overflow(stackBuf,idx,a_stack_vptr);
              (&b_stack )->g();
            } else if(vtable.compare("injection") == 0) {                   // # INJECTION

            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {  // ### SUB OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE
              // (8) hijack stack independent sub_object_bounds_overflow vptr reuse
              printf("Exploit (8)\n");
              long long idx = (void **)&b_stack - b_stackBuf;
              overflow(b_stackBuf,idx,a_stack_vptr);
              (&b_stack)->g();
            } else if(vtable.compare("injection") == 0) {                   // # INJECTION

            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {            // ### TYPE CONFUSION
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {
              // (9) hijack stack independent type_confusion vptr reuse
              printf("Exploit (9)\n");
              C *c;
              c = (C *)&b_stack;
              confusion(c,a_stack_vptr);
              (&b_stack)->g();
            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("inherited") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
            //(10) hijack stack inherited object_bounds_overflow object_ptr
            printf("Exploit (10)\n");
            Base * buf[10];
            long long idx = &n_base_heap - buf;
            buf[idx] = e_base_heap;
            n_base_heap->g();

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
            // (11) hijack stack inherited type_confusion object_ptr
            printf("Exploit (11)\n");
            Normal* n = (Normal *)&e_evil_stack;
            n->g();
          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {
            // (12) hijack stack inherited use_after_free object_ptr
            printf("Exploit (12)\n");
            Normal * n = createNormalOnStack();
            createEvilAndPrintFromNormal(n);
            //TODO: pass pointer through global variable      ###############################################

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("multiple_inheritance") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else {
        printf("Invalid Class Heirarchy");
      }

    } else if(memoryLocation.compare("global") == 0) {      // ##### GLOBAL

      if(classHeirarchy.compare("independent") == 0) {          // #### INDEPENDENT
        if(type.compare("object_bounds_overflow") == 0) {           // ### OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE

            } else if(vtable.compare("injection") == 0) {                   // # INJECTION

            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {  // ### SUB OBJECT BOUNDS OVERFLOW
          if(pointer.compare("vptr") == 0) {                            // ## VPTR
            if(vtable.compare("reuse") == 0) {                              // # REUSE

            } else if(vtable.compare("injection") == 0) {                   // # INJECTION

            } else if(vtable.compare("corruption") == 0) {                  // # CORRUPTION

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {               // ## OBJECT PTR

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {            // ### TYPE CONFUSION
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("inherited") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else if(classHeirarchy.compare("multiple_inheritance") == 0) {
        if(type.compare("object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("sub_object_bounds_overflow") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("type_confusion") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else if(type.compare("use_after_free") == 0) {
          if(pointer.compare("vptr") == 0) {
            if(vtable.compare("reuse") == 0) {

            } else if(vtable.compare("injection") == 0) {

            } else if(vtable.compare("corruption") == 0) {

            } else {
              printf("Invalid vtable");
            }
          } else if(pointer.compare("object_ptr") == 0) {

          } else {
            printf("Invalid Pointer");
          }

        } else {
          printf("Invalid Type");
        }

      } else {
        printf("Invalid Class Heirarchy");
      }

    } else {
      printf("Invalid Memory Location");
    }

    //
    // //13. indirect pointer overwrite (pointer subterfuge)
    // {
    //   Evil * e = new Evil();
    //   Normal * n = new Normal();
    //   void * ptr;
    //   void * buf[10];
    //   long long idx = &ptr - buf;
    //   buf[idx] = (void *)n;
    //   assert(ptr == (void *)n);
    //   memcpy(ptr, (void *)e, sizeof(void *));
    //   n->g();
    // }
    //
    //
    // // TYPE OF ATTACK X STACK/HEAP/GlOBAL X HEIRARCHY(Independent, Inheritance, Multiple Inheritance)



    return 0;
}
