#include <cassert>
#include <cstdio>
#include <string>
#include <string.h>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

string memoryLocation;
string classHeirarchy;
string type;
string pointer;
string vtable;

class A
{
    private:

        int x;

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C *c, void *ptr)   // valid
{
    c->set(ptr);
}

class Base {
public:
  void *buf[3];
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Normal * createNormalOnStack() {
  double x =0;
  Normal n = Normal();
  return &n;
}

void createEvilAndPrintFromNormal(Normal * n) {
  Evil e = Evil();
  assert((void *)n == (void *)&e);
  n->g();
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}

void callg(void * target) {
  if(classHeirarchy == "independent") {
    ((B *)target)->g();
  } else if(classHeirarchy == "inherited") {
    ((Base *)target)->g();
  } else if(classHeirarchy == "multiple_inheritance") {

  } else {

  }
}

void ** getBuf(void * target) {
  if(classHeirarchy == "independent") {
    return ((B *)target)->buf;
  } else if(classHeirarchy == "inherited") {
    return ((Base *)target)->buf;
  } else if(classHeirarchy == "multiple_inheritance") {
    return NULL;
  } else {
    return NULL;
  }
}


int main(int argc, char * argv[])
{
    memoryLocation = argv[1];
    classHeirarchy = argv[2];
    type = argv[3];
    pointer = argv[4];
    if(argc>5) {
    vtable = argv[5];
    }

    cout << "Attack: " << memoryLocation << " " << classHeirarchy << " " << type << " " << pointer << " " << vtable << endl;

    FakeVirtualTable fake_table;
    fake_table.g = fake_g;

    A * a;
    B * b;
    void **buf;
    void * bad_vptr;
    Base * base_e;
    Base * base_n;
    Normal * n;
    Evil * e;
    void * e_vptr;
    Base base_n_stack = Normal();
    Base base_e_stack = Evil();
    Evil e_stack = Evil();
    Normal n_stack = Normal();

    if(memoryLocation == "heap") {
      a = new A(1);
      b = new B(1.0);
      buf = new void *[10];
      base_e = new Evil();
      base_n = new Normal();
      n = new Normal();
      e = new Evil();
    } else if(memoryLocation == "stack") {
      A a_stack = A(1);
      B b_stack = B(1.0);
      void * stackBuf[10];
      a = &a_stack;
      b = &b_stack;
      buf = stackBuf;
      base_e = &base_e_stack;
      base_n = &base_n_stack;
      n = &n_stack;
      e = &e_stack;
    } else if(memoryLocation == "global") {
      return 0;
    } else {
      printf("Invalid memory location\n");
      return 0;
    }

    if(vtable == "reuse") {
      memcpy((void *)&bad_vptr, (void *)a, sizeof(void *));
    } else if(vtable == "injection") {
      bad_vptr = (void *)&fake_table;
    } else if(vtable == "corruption") {
      return 0;
    } else {
      printf("Invalid vtable\n");
      return 0;
    }
    memcpy((void *)&e_vptr, (void *)base_e, sizeof(void *));

    void * target;
    void * badObject;
    if(classHeirarchy == "independent") {
      target = (void *)b;
      badObject = (void *)a;
    } else if(classHeirarchy == "inherited") {
      target = (void *)base_n;
      badObject = (void *)base_e;
    } else if(classHeirarchy == "multiple_inheritance") {

    } else {
      printf("Invalid Class Heirarchy");
      return 0;
    }

    if(type == "object_bounds_overflow") {
      if(pointer =="vptr") {
        // (1)(7)(13)(17) hijack heap/stack/global independent/inherited object_bounds_overflow vptr reuse
        long long idx = (void **)target - buf;
        overflow(buf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {
        //(10) hijack heap/stack independent/inherited object_bounds_overflow object_ptr
        long long idx = &target - (void **)buf;
        buf[idx] = badObject;
        callg(target);
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "sub_object_bounds_overflow") {
      if(pointer =="vptr") {
        // (2)(8)(14) hijack heap/stack independent sub_object_bounds_overflow vptr reuse
        void ** targetBuf = getBuf(target);
        long long idx = (void **)target - targetBuf;
        overflow(targetBuf, idx, bad_vptr);
        callg(target);
      } else if(pointer == "object_ptr") {

      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "type_confusion") {
      if(pointer =="vptr") {
        // (3)(9)(15) hijack heap/stack independent type_confusion vptr reuse
        C *c;
        c = (C *)target;
        confusion(c,bad_vptr);
        callg(target);
        //TODO: inherited version  ##################### (not possible?)
      } else if(pointer == "object_ptr") {
        // (5)(11) heap/stack inherited type_confusion object_ptr
        n = (Normal*)(base_e);
        n->g();
        //TODO: independent version  ########################
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    } else if(type == "use_after_free") {
      if(pointer =="vptr") {
        // (4)(16) hijack heap independent use_after_free vptr reuse
        C *c = new C;
        delete c;
        b = new B(1.0);
        assert((void *)c == (void *)b);
        confusion(c,bad_vptr);
        b->g();
        //TODO: inherited version ########################
      } else if(pointer == "object_ptr") {
        if(memoryLocation == "heap") {
            // (6) hijack heap inherited use_after_free object_ptr
            Normal *n = new Normal();
            delete n;
            Evil *e = new Evil();
            n->g();
            //TODO: make enough objects to get same address  ########################################################
        } else if(memoryLocation  == "stack") {
            // (12) hijack stack inherited use_after_free object_ptr
            Normal * n = createNormalOnStack();
            createEvilAndPrintFromNormal(n);
            //TODO: pass pointer through global variable      ###############################################
        }
        //TODO:: independent version for object ptr #########################
      } else {
        printf("Invalid Pointer\n");
        return 0;
      }
    }

    //
    // //13. indirect pointer overwrite (pointer subterfuge)
    // {
    //   Evil * e = new Evil();
    //   Normal * n = new Normal();
    //   void * ptr;
    //   void * buf[10];
    //   long long idx = &ptr - buf;
    //   buf[idx] = (void *)n;
    //   assert(ptr == (void *)n);
    //   memcpy(ptr, (void *)e, sizeof(void *));
    //   n->g();
    // }
    //
    //
    // // TYPE OF ATTACK X STACK/HEAP/GlOBAL X HEIRARCHY(Independent, Inheritance, Multiple Inheritance)



    return 0;
}
