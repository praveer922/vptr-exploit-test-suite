#include <cassert>
#include <cstdio>
#include <string>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

static int hijackCount = 0;

class A
{
    private:

        int x;

    public:

        A(int y) : x(y) { }

        virtual void f(void)
        {
            printf("HIJACKED!\n");
            hijackCount++;
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];

        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }
};


static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C *c, void *ptr)   // valid
{
    c->set(ptr);
}

class Base {
public:
  virtual void g() {
    printf("OK!\n");
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
      hijackCount++;
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
};

Normal * createNormalOnStack() {
  double x =0;
  Normal n = Normal();
  return &n;
}

void createEvilAndPrintFromNormal(Normal * n) {
  Evil e = Evil();
  assert((void *)n == (void *)&e);
  n->g();
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}


int main(int argc, char * argv[])
{
    string memoryLocation = argv[1];
    string classHeirarchy = argv[2];
    string type = argv[3];
    string pointer = argv[4];
    string vtable;
    if(argc>5) {
    vtable = argv[5];
    }

    A *a_heap = new A(1);
    B *b_heap = new B(1.0);
    void **heapBuf = new void *[10];
    void **b_heapBuf = b_heap->buf;
    void *a_heap_vptr;
    memcpy((void *)&a_heap_vptr, (void *)a_heap, sizeof(void *));

    Base * e_base_heap = new Evil();
    Normal * n_normal_heap = new Normal();

    A a_stack = A(1);
    B b_stack = B(1.0);
    void * stackBuf[10];
    void ** b_stackBuf = b_stack.buf;
    void *a_stack_vptr;
    memcpy((void *)&a_stack_vptr, (void *)&a_stack, sizeof(void *));

    Evil e_evil_stack = Evil();

    if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("object_bounds_overflow") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) {  // (1) OBJECT BOUNDS OVERFLOW
        printf("Exploit (1)\n");
        long long idx = (void **)b_heap - heapBuf;
        overflow(heapBuf, idx, a_heap_vptr);
        b_heap->g();

    } else if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("sub_object_bounds_overflow") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) { // (2) SUB-OBJECT BOUNDS OVERFLOW (UNDERFLOW)
        printf("Exploit (2)\n");
        long long idx = (void **)b_heap - b_heapBuf;
        overflow(b_heapBuf, idx, a_heap_vptr);
        b_heap->g();

    } else if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("type_confusion") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) { // (3) TYPE CONFUSION
        printf("Exploit (3)\n");
        C *c;
        c = (C *)b_heap;
        confusion(c,a_heap_vptr);
        b_heap->g();

    } else if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("use_after_free") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) {
        printf("Exploit (4)\n");
        C *c = new C;
        delete c;
        B *b = new B(1.0);
        assert((void *)c == (void *)b);
        confusion(c,a_heap_vptr);
        b->g();
    } else if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("inherited") == 0 && type.compare("type_confusion") == 0
    && pointer.compare("object_ptr") == 0) {
      printf("Exploit (5)\n");
      n_normal_heap = static_cast<Normal*>(e_base_heap);
      n_normal_heap->g();

    } else if(memoryLocation.compare("heap") == 0 && classHeirarchy.compare("inherited") == 0 && type.compare("use_after_free") == 0
    && pointer.compare("object_ptr") == 0) {
      printf("Exploit (6)\n");
      Normal *n = new Normal();
      delete n;
      Evil *e = new Evil();
      n->g();
      //TODO: make enough objects to get same address
    } else if(memoryLocation.compare("stack") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("object_bounds_overflow") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) {
      printf("Exploit (7)\n");
      long long idx = (void **)&b_stack - stackBuf;
      overflow(stackBuf,idx,a_stack_vptr);
      (&b_stack )->g();

    } else if(memoryLocation.compare("stack") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("sub_object_bounds_overflow") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) {
      printf("Exploit (8)\n");
      long long idx = (void **)&b_stack - b_stackBuf;
      overflow(b_stackBuf,idx,a_stack_vptr);
      (&b_stack)->g();

    } else if(memoryLocation.compare("stack") == 0 && classHeirarchy.compare("independent") == 0 && type.compare("type_confusion") == 0
    && pointer.compare("vptr") == 0 && vtable.compare("reuse") == 0) {
      printf("Exploit (9)\n");
      C *c;
      c = (C *)&b_stack;
      confusion(c,a_stack_vptr);
      (&b_stack)->g();

    } else if(memoryLocation.compare("stack") == 0 && classHeirarchy.compare("inherited") == 0 && type.compare("type_confusion") == 0
    && pointer.compare("object_ptr") == 0) {
      printf("Exploit (10)\n");
      Normal* n = (Normal *)&e_evil_stack;
      n->g();
    } else if(memoryLocation.compare("stack") == 0 && classHeirarchy.compare("inherited") == 0 && type.compare("use_after_free") == 0
    && pointer.compare("object_ptr") == 0) {
      printf("Exploit (11)\n");
      Normal * n = createNormalOnStack();
      createEvilAndPrintFromNormal(n);
    }

    //
    // //12. overwrite Normal * ptr to an Evil ptr
    // {
    //   Base * e = new Evil();
    //   Base * n = new Normal();
    //   Base * buf[10];
    //   long long idx = &n - buf;
    //   buf[idx] = e;
    //   n->g();
    // }
    //
    // //13. indirect pointer overwrite (pointer subterfuge)
    // {
    //   Evil * e = new Evil();
    //   Normal * n = new Normal();
    //   void * ptr;
    //   void * buf[10];
    //   long long idx = &ptr - buf;
    //   buf[idx] = (void *)n;
    //   assert(ptr == (void *)n);
    //   memcpy(ptr, (void *)e, sizeof(void *));
    //   n->g();
    // }
    //
    // {
    //   printf("%s%d%s%d\n", "Hijack Count = ",hijackCount,"/",13);
    // }
    //
    // //14. Overwrite vptr to own vtable constructed in buffer -
    // //not working currently, segfaults (Evil::g in vtable )
    // {
    //   A *a = new A(1);
    //   B *b = new B(1.0);
    //   void **buf = new void *[10];
    //   long long idx = (void **)b - buf;
    //
    //   FakeVirtualTable custom_table;
    //   custom_table.g = fake_g;
    //
    //   //void *ptr;
    //   //memcpy((void *)&ptr, (void *)&custom_table, sizeof(void *));
    //   overflow(buf, idx, (void *)&custom_table);
    //   b->g();
    // }
    //
    // // TYPE OF ATTACK X STACK/HEAP/GlOBAL X HEIRARCHY(Independent, Inheritance, Multiple Inheritance)



    return 0;
}
