#include <cassert>
#include <cstdio>
#include <string>
#include <string.h>
#include <iostream>

using namespace std;

#define NOINLINE    __attribute__((__noinline__))

string memoryLocation;
string classHeirarchy;
string type;
string pointer;
string vtable;

void * customHeap = malloc(4000);

class A
{

    public:

        float z;
        void *pad[3];
        int x;
        A() {}
        A(int y) : x(y) { }

        virtual void g(void)
        {
            printf("HIJACKED!\n");
        }

        void * operator new(size_t size) {
          void * a = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(A));
          return a;
        }

        void operator delete(void * a) {
            customHeap = a;
        }
};


class B
{
    private:



    public:
          float z;
        void *buf[3];
        B() {}
        B(float w) : z(w) { }

        virtual void g(void)
        {
            printf("OK\n");
        }

        void * operator new(size_t size) {
          void * a = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(A));
          return a;
        }

        void operator delete(void * a) {
            customHeap = a;
        }
};

class C
{
    private:

        void *ptr;

    public:

        float pad1;             // Pad to same size as B
        void *pad2[3];

        C() : ptr(nullptr) { }

        void set(void *x)
        {
            ptr = x;
        }

        void * operator new(size_t size) {
          void * a = customHeap;
          customHeap = (void *)((char *)customHeap + sizeof(A));
          return a;
        }

        void operator delete(void * a) {
            customHeap = a;
        }
};

class D {
  public:
    float z;
    A a;
    virtual void g(void)
    {
        printf("OK\n");
    }

    void * operator new(size_t size) {
      void * a = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(A));
      return a;
    }

    void operator delete(void * a) {
        customHeap = a;
    }
};

class E {
  public:
    float z;
    void *buf;
//    float z;
//    void *pad[3];
//    int x;
    virtual void g(void)
    {
        printf("OK\n");
    }

    void * operator new(size_t size) {
      void * a = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(A));
      return a;
    }

    void operator delete(void * a) {
        customHeap = a;
    }
};

class Base {
public:
  void *buf[3];
  int x;
  virtual void g() {
    printf("OK!\n");
  }

  void * operator new(size_t size) {
    void * a = customHeap;
    customHeap = (void *)((char *)customHeap + sizeof(A));
    return a;
  }

  void operator delete(void * a) {
      customHeap = a;
  }
};

class Evil: public Base {
  public:
    virtual void g() {
      printf("HIJACKED!\n");
    }

    void * operator new(size_t size) {
      void * a = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(A));
      return a;
    }

    void operator delete(void * a) {
        customHeap = a;
    }
};

class Normal: public Base {
  public:
    virtual void g() {
      printf("OK\n");
    }
    void * operator new(size_t size) {
      void * a = customHeap;
      customHeap = (void *)((char *)customHeap + sizeof(A));
      return a;
    }

    void operator delete(void * a) {
        customHeap = a;
    }
};

static NOINLINE void overflow(void **buf, long long idx, void *ptr)
{
    buf[idx] = ptr;
}

static NOINLINE void confusion(C * c, void *ptr)  {
  c->set(ptr);
}

Base * globalBase;
Normal * globalNormal;
Evil * globalEvil;
C * globalC;
B * globalB;
A * globalA;

A globalAObj = A(1);
B globalBObj = B(1.0);
Normal globalNormalObj = Normal();
Evil globalEvilObj = Evil();
void * globalBuf[10];
void * fakeTargetGlobal[10];

void createBaseOnStack() {
  Base b = Base();
  globalBase = &b;
  printf("globalBase at %p\n", globalBase);
}

void createNormalOnStack() {
  Normal n = Normal();
  globalNormal = &n;
  printf("globalNormal at %p\n", globalNormal);
}

void createEvilOnStack() {
  Evil e = Evil();
  globalEvil = &e;
  printf("globalEvil at %p\n", globalEvil);
}

void createConStack() {
  C c = C();
  globalC = &c;
  printf("globalC at %p\n", globalC);
}

void createBonStack() {
  B b = B(1.0);
  globalB = &b;
  printf("globalB at %p\n", globalB);
}

void createAonStack() {
  A a = A(1);
  globalA = &a;
  printf("globalA at %p\n", globalA);
}

typedef void (*virtual_function)();

struct FakeVirtualTable {
    virtual_function g;
};

void fake_g()
{
    printf("HIJACKED!\n");
}

void callg(void * target) {
  if(classHeirarchy == "independent") {
    ((B *)target)->g();
  } else if(classHeirarchy == "inherited") {
    ((Base *)target)->g();
  } else if(classHeirarchy == "multiple_inheritance") {

  } else {

  }
}

void ** getBuf(void * target) {
  if(classHeirarchy == "independent") {
    return ((B *)target)->buf;
  } else if(classHeirarchy == "inherited") {
    return ((Base *)target)->buf;
  } else if(classHeirarchy == "multiple_inheritance") {
    return NULL;
  } else {
    return NULL;
  }
}

int main(int argc, char * argv[]) {

  // memoryLocation = argv[1];
  // classHeirarchy = argv[2];
  // type = argv[3];
  // pointer = argv[4];
  // vtable = argv[5];

  //cout << "Attack Signature: " << memoryLocation << " " << classHeirarchy << " " << type << " " << pointer << " " << vtable << endl;

  // //Test 1: independent objects
  // A * a = new A(1);
  // B * b  = new B(1.0);
  // memcpy((void *)b, (void *)a, sizeof(void *));
  // b->g();
  // delete a;
  // delete b;
  //
  // //Test 2: Inherited objects
  // Normal * n = new Normal();
  // Evil * e = new Evil();
  // memcpy((void *)n, (void *)e, sizeof(void *));
  // n->g();
  // delete n;
  // delete e;

  // //Test 3:
  // B * fakeB = (B *)malloc(sizeof(B));
  // A * a3 = new A(1);
  // memcpy((void *)fakeB, (void *)a3, sizeof(void *));
  // fakeB->g();
  // delete a3;
  //
  // //Test 4:
  // A * a4 = new A(1);
  // B * b4 = new B(1.0);
  // memcpy((double *)a4 + 1, ((double *)b4)+1, sizeof(B)-8);
  // assert(b4->z == a4->z);
  // a4->g();
  // delete b4;
  // delete a4;

  printf("REached\n");
  //Test 5
  D * d = new D();
  A * _a = &d->a;
  void * bad_vptr;
  memcpy((void *)&bad_vptr, (void *)&(d->a), sizeof(void *));
  delete d;
  E * _e = new E();
  memcpy((void *)&(_e->buf), (void *)&bad_vptr, sizeof(void *));
  //(&(_e->b))->g();
  _a->g();


return 0;
}
